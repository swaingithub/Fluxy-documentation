---
title: Reactive Architecture
description: The philosophy behind Fluxy's reactivity and state management.
---

# Reactive Architecture

The core philosophy of Fluxy is to minimize re-renders and make data flow explicit.

## The Reactive Graph

Fluxy uses a **Signal Graph** to track dependencies. Every `Signal`, `Computed`, and `Effect` is a node in this graph.

<div className="p-4 border border-border rounded-lg bg-red-500/10 text-red-700 dark:text-red-400 font-medium">
  ⚠️ This is different from traditional `setState()` which rebuilds entire widget subtrees.
</div>

When a `Signal` updates, it notifies only its direct dependents. If a `Computed` value depends on that signal, it recalculates. If an `Effect` uses that signal, it re-runs. This ensures that only the necessary parts of your UI update.

## Single Engine Philosophy

Instead of relying on multiple disjointed state management solutions, navigation libraries, and theme extensions, everything in Fluxy is unified under a single **Engine** instance. This engine coordinates:

*   **State Updates**: Automatic batching and dependency tracking.
*   **Routing**: Managing the navigation stack and history.
*   **Theming**: Applying global styles and responsive breakpoints.
*   **OTA Updates**: Handling remote manifest downloads and hot-swaps.

This unification reduces complexity and ensures that all parts of your application work together seamlessly.

## Performance First

Performance is built-in, not an afterthought.

*   **Fine-Grained Updates**: Only change the specific text node or style property that needs to update.
*   **Lazy Evaluation**: `Computed` values are only calculated when accessed.
*   **Zero Overhead**: While the developer experience is rich, the runtime cost is minimal.
