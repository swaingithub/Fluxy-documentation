---
title: Reactive Architecture
description: The philosophy behind Fluxy's reactivity and state management.
---

# Reactive Architecture

The core philosophy of Fluxy is to minimize re-renders and make data flow explicit.

## The Reactive Graph

Fluxy uses a **Signal Graph** (Flux System) to track dependencies. Every `Flux`, `FluxComputed`, and `FluxEffect` is a node in this graph.

<div className="p-4 border border-border rounded-lg bg-red-500/10 text-red-700 dark:text-red-400 font-medium">
  This is different from traditional `setState()` which rebuilds entire widget subtrees.
</div>

When a `Flux` updates, it notifies only its direct dependents. If a `FluxComputed` value depends on that signal, it recalculates. If a `FluxEffect` uses that signal, it re-runs. This ensures that only the necessary parts of your UI update.

## Architectural Authority

Fluxy v0.1.9 formalizes the **Architectural Authority** of the framework, moving from a library to an application platform. It enforces clean separation of concerns through standardized base classes:

*   **Logic Layer (`FluxController`)**: Handles business logic with native lifecycle hooks (`onInit`, `onReady`, `onDispose`).
*   **Data Layer (`FluxRepository`)**: Manages offline-first data orchestration with automatic Local/Remote synchronization.
*   **Feature-First Structure**: Enforces a `lib/features` and `lib/core` directory convention for scalable, enterprise-grade development.

## Single Engine Philosophy

Instead of relying on multiple disjointed state management solutions, navigation libraries, and networking engines, everything in Fluxy is unified under a single **Engine** instance. This engine coordinates:

*   **State Updates**: Automatic batching and dependency tracking.
*   **Networking**: Native `FluxyHttp` engine with global interceptors.
*   **Routing**: Managing the navigation stack and history with automatic controller factory.
*   **Theming**: Applying global styles and responsive breakpoints.
*   **OTA Updates**: Handling remote manifest downloads and hot-swaps.

This unification reduces complexity and ensures that all parts of your application work together seamlessly.

## Performance First

Performance is built-in, not an afterthought.

*   **Fine-Grained Updates**: Only change the specific text node or style property that needs to update.
*   **Lazy Evaluation**: `Computed` values are only calculated when accessed.
*   **Zero Overhead**: While the developer experience is rich, the runtime cost is minimal.

## Flat Widget Tree (Attribute Accumulation)

Fluxy v0.1.6 optimizes UI performance through a **Flat Widget Tree**. Unlike traditional modifier-based frameworks that wrap widgets in nested layers (Padding > DecoratedBox > Opacity), Fluxy uses an **Attribute Accumulation** pattern.

When you chain modifiers:
```dart
Fx.box()
  .p(16)
  .bg(Colors.blue)
  .rounded(12)
  .shadow.lg
```
The engine accumulates these attributes into a single internal style object. This results in far fewer widgets in the element tree, leading to better memory usage and faster layout passes.

## Structural Recursion (ParentData Preservation)

Fluxy's engine is designed to be "layout aware." It uses **Structural Recursion** to correctly handle Flutter's `ParentData` requirements. 

If you apply modifiers to widgets like `Expanded`, `Flexible`, or `Positioned`, Fluxy "peers through" these wrappers to apply styles to the inner child without breaking the communication between the layout widget and its parent (like a `Row` or `Stack`). This eliminates the common "Incorrect use of ParentDataWidget" errors.
