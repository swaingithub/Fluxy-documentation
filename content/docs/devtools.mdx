---
title: DevTools & Debugging
description: Inspect state and performance in real-time.
---

# DevTools & Fluxy Inspector

Fluxy v0.2.0 introduces a premium, glassmorphic **Fluxy Inspector** that provides unprecedented visibility into your application's internals.

## Enable Inspector

To activate the high-end debugging interface, wrap your root application with `Fluxy.debug`:

```dart
runApp(Fluxy.debug(child: MyApp()));
```

## Core Inspector Modules

### 1. Glassmorphic HUD
A Floating Action Button appears in debug mode. Tapping it opens the primary inspector shield, featuring a modern glassmorphic UI with real-time system mirrors.

### 2. DI Registry Inspector
Inspect every registered dependency within the `FluxyDI` container.
- View lifecycle scopes (`app`, `route`, `factory`).
- Check initialization status and lazy-loading states.
- Monitor active instances to prevent memory leaks.

### 3. Network Activity Logs
A specialized engine that monitors all HTTP traffic.
- **Latency Tracking**: See exactly how long each request takes.
- **Payload Inspection**: View request headers, response bodies, and error codes in a formatted JSON viewer.
- **Timeline**: Chronological view of all network events.

### 4. State Update Timeline
A real-time ticker showing every flux/signal update across the system. 
- Trace the origin of state changes.
- Identify "dirty" updates that might be triggering unnecessary re-renders.

## Global Error Pipeline (`Fx.onError`)

Starting from v0.2.0, you can pipe all framework and platform errors to a single expressive sink:

```dart
void main() {
  Fx.onError((error, stack) {
    // Pipe to Sentry, Firebase, or your own backend
    print("Intercepted Error: $error");
  });
  
  runApp(Fluxy.debug(child: MyApp()));
}
```

This pipeline captures:
- Flutter framework exceptions (Widget errors).
- Asynchronous errors (Future/Stream failures).
- Platform-level exceptions.
