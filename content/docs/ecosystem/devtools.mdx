---
title: DevTools & Debugging
description: Inspect state and performance in real-time.
---

# DevTools & Fluxy Inspector

The **Fluxy Inspector** provides a premium, glassmorphic debugging interface with real-time feedback and advanced productivity features.

## Enable Inspector

To activate the high-end debugging interface, wrap your root application with `Fluxy.debug`:

```dart
runApp(Fluxy.debug(child: MyApp()));
```

## Core Inspector Modules

### 1. Premium Glassmorphic HUD
A Floating Action Button appears in debug mode. Tapping it opens the primary inspector shield, featuring a modern glassmorphic UI with high-performance blur effects and real-time system mirrors.

### 2. Flux Registry (Search & Live Edit)
Inspect every registered flux/signal in your system.
- **Search & Filter**: Find fluxes by name or ID instantly.
- **Live Value Editing**: Update `boolean`, `string`, and `numeric` values directly from the UI to test edge cases without hot-reloads.
- **Update Flashing**: Signals now briefly flash blue in the list when their value changes.

### 3. DI Registry Inspector
Inspect every registered dependency within the `FluxyDI` container.
- **Lifecycle Scopes**: View `app`, `route`, and `factory` scopes.
- **Initialization Tracking**: Check initialization status and lazy-loading states.
- **Auto-Cleanup**: Monitor dependencies that are disposed when routes are popped.

### 4. Network Activity Logs
A specialized engine that monitors all HTTP traffic.
- **JSON Prettifier**: Request and response bodies are automatically formatted with indentation.
- **Clipboard API**: One-tap copy for headers, bodies, and URLs.
- **Latency Tracking**: See exactly how long each request takes.

### 5. State Update Timeline
A real-time ticker showing every flux update across the system. 
- **Timeline Controls**: Search, pause/resume, and clear functionality.
- **Trace Origins**: Identify exactly when and where state changes occurred.

## Self-Contained Performance

As of v0.2.1, the Inspector is fully **context-independent**. It no longer requires a `ScaffoldMessenger`, `Overlay`, or `MaterialLocalizations` in your app tree to function, making it safe to use even in minimal app configurations.

## Global Error Pipeline (`Fx.onError`)

Starting from v0.2.0, you can pipe all framework and platform errors to a single expressive sink:

```dart
void main() {
  Fx.onError((error, stack) {
    // Pipe to Sentry, Firebase, or your own backend
    print("Intercepted Error: $error");
  });
  
  runApp(Fluxy.debug(child: MyApp()));
}
```

This pipeline captures:
- Flutter framework exceptions (Widget errors).
- Asynchronous errors (Future/Stream failures).
- Platform-level exceptions.
