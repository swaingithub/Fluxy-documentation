# OTA Engine & Server-Driven UI [EXPERIMENTAL]

<Callout type="warn" title="Experimental Feature">
  The Fluxy OTA Engine is currently in **Alpha/Testing**. API stability is not guaranteed, and remote manifest schemas are subject to change. Use in production with caution.
</Callout>

The Fluxy OTA (Over-The-Air) Engine enables you to modify your application's UI, layouts, and even basic logic in real-time without requiring a new store submission.

## Architecture

The engine works by fetching a **JSON Manifest** from your remote server, parsing it through the `FluxyRenderer`, and swapping components dynamically using the **Atom/Molecule Swap** pattern.

## 1. Server-Driven UI (SDUI)

SDUI allows you to send a UI definition over the wire. This is perfect for home-screen promotions, emergency banners, or A/B testing variations.

### Rendering a Remote View
Use the `FxRemoteView` widget to create a placeholder that hydrates from the server.

```dart
FxRemoteView(
  url: "https://api.myapp.com/v1/layout/seasonal-banner",
  loading: Fx.loader.shimmer(height: 100),
  error: (err) => Fx.text("Offline Content"),
)
```

### Manifest Schema Example
```json
{
  "type": "box",
  "style": { "padding": 24, "bg": "slate.900", "radius": 20 },
  "children": [
    {
      "type": "text",
      "data": "Flash Sale!",
      "style": { "fontSize": 20, "bold": true, "color": "white" }
    },
    {
      "type": "button",
      "label": "Claim Now",
      "action": "navigate:/offers/flash-sale"
    }
  ]
}
```

## 2. Dynamic Actions
The OTA engine can trigger local application navigation and event logic through the `action` parser.

- `navigate:/path`: Pushes a local route.
- `toast:message`: Triggers an `Fx.toast`.
- `event:name`: Log a custom event to `Fx.analytics`.

## 3. Atomic Updates
You can update the entire application state by calling the main `Fx.platform.ota.update()` method during the splash or background sync.

```dart
Future<void> checkForUpdates() async {
  await Fx.platform.ota.update("https://cdn.myapp.com/latest_v2.json");
  // The app will now use the new manifest for all RemoteViews
}
```

## 4. Remote Plugin Kill-switch

The OTA engine provides critical production safety. You can remotely disable specific platform modules via the manifest `disabled_plugins` array to instantly neutralize production crashes without waiting for a store update.

```json
{
  "version": "1.2.0",
  "disabled_plugins": ["fluxy_biometric"],
  "ui": { ... }
}
```

This will prevent the `fluxy_biometric` module from booting up on the next app launch.

## Best Practices
1. **Fallback UI**: Always provide a local "fallback" child to `FxRemoteView` so your app remains functional even in "Isolated" (offline) networking modes.
2. **Version Control**: Include a `min_version` field in your JSON manifests to ensure new UI features don't crash older app versions.
3. **Safety First**: Use the `disabled_plugins` feature sparingly as an emergency "Big Red Button" for unexpected production regressions in native modules.
4. **Cache Strategy**: Fluxy's OTA engine uses `Fx.storage` internally to cache manifests. Updates only trigger when the remote `etag` or `version` hash changes.


