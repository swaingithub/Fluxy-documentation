---
title: Layout & Alignment
description: Declarative, explicit, and zero-math layout system.
---

# Layout & Alignment

**Declarative. Explicit. Zero Math.**

Fluxy's layout system eliminates the need for manual `Spacer` or `SizedBox` management by treating **Spacing as a property of the container**.

---

## Fx.row & Fx.col (Flexbox Mastery)

Distribute space and align items with named semantic parameters.

### Comparison

**Standard Flutter (Manual Spacing)**
```dart
Row(
  mainAxisAlignment: MainAxisAlignment.spaceBetween,
  children: [
    Icon(Icons.star),
    SizedBox(width: 8),
    Text("Rating"),
    SizedBox(width: 8),
    Icon(Icons.chevron_right),
  ],
)
```

**Fluxy DSL (Intelligent Gap)**
```dart
Fx.row(
  justify: MainAxisAlignment.spaceBetween,
  gap: 8,
  children: [
    Icon(Icons.star),
    Fx.text("Rating"),
    Icon(Icons.chevron_right),
  ],
)
```

---

### The Stability-First Default (`MainAxisSize.min`)

One of the most significant differences between Fluxy and standard Flutter is the default behavior of Flex containers.

- **Standard Flutter**: `Row` and `Column` default to `MainAxisSize.max` (occupying all available space).
- **Fluxy DSL**: `Fx.row` and `Fx.col` default to `MainAxisSize.min` (occupying only as much space as their children need).

#### Why this matters for Alignment
Because Fluxy containers default to `min`, using `justify: MainAxisAlignment.spaceBetween` will appear to "not work" out of the box. Since the row is only as wide as its children, there is no "leftover space" to distribute between them.

**The Fix:** To use justified spacing (like pinning elements to the left and right edges), you must explicitly tell the container to take up all available space using `size: MainAxisSize.max`.

```dart
Fx.row(
  justify: MainAxisAlignment.spaceBetween,
  size: MainAxisSize.max, // <--- Required for space distribution
  children: [ 
    Fx.text("Left"),
    Fx.text("Right"),
  ],
)
```

#### Philosophy: Why the change?
Fluxy prioritizes **Layout Stability**. Defaulting to `min` prevents "infinite size" crashes when flexible containers are nested inside scrollable viewports. It forces you to be intentional about expansion, resulting in more robust and predictable UIs.

---

## Fx.grid (The Layout Workhorse)

The Grid API handles all the aspect ratio and column math for you.

### Comparison

**Standard Flutter**
```dart
GridView.count(
  crossAxisCount: 2,
  mainAxisSpacing: 16,
  crossAxisSpacing: 16,
  childAspectRatio: 0.8,
  children: [ ... ],
)
```

**Fluxy DSL**
```dart
Fx.grid(
  columns: 2,
  gap: 16,
  childAspectRatio: 0.8,
  children: [ ... ],
)
```

---

## Fx.stack (Overlay Layout)

Stacks widgets on top of each other with simplified alignment and positioning.

### Comparison

**Standard Flutter**
```dart
Stack(
  alignment: Alignment.center,
  children: [
    Container(width: 200, height: 200, color: Colors.blue),
    Positioned(
      bottom: 10,
      right: 10,
      child: Icon(Icons.star),
    ),
  ],
)
```

**Fluxy DSL**
```dart
Fx.stack(
  alignment: Alignment.center,
  children: [
    Fx.box().size(200, 200).bg(Colors.blue),
    Icon(Icons.star).align(bottom: 10, right: 10),
  ],
)
```

---

## Layout Intelligence (Structural Recursion)

Fluxy handles `ParentData` automatically, preventing common layout crashes.

### Comparison

**Standard Flutter (Explicit Wrapping)**
```dart
Row(
  children: [
    Text("Title"),
    Expanded(
      child: Container(color: Colors.red),
    ),
  ],
)
```

**Fluxy DSL (Late Binding)**
```dart
Fx.row().children([
  Fx.text("Title"),
  Fx.box().bg(Colors.red).expanded(),
])
```
