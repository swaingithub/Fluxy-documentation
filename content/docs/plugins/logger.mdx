---
title: System Logger & Audit
description: Premium sensory UX with centralized haptic vibration control.
---

# System Logger & Audit

Fluxy's Logger Engine provides a semantic API for digital touch confirmation, abstracting away raw platform vibration calls.

## [GUIDE] Industrial Step-by-Step

### 1. Installation (via CLI)
Add the logger module using the Fluxy CLI to maintain architectural integrity.
```bash
fluxy module add logger
```

### 2. Managed Boot Sequence
Ensure your `main.dart` is configured with the mandatory three-step boot sequence.
```dart
import 'package:fluxy/fluxy.dart';
import 'core/registry/fluxy_registry.dart'; 

void main() async {
  await Fluxy.init();
  Fluxy.registerRegistry(() => registerFluxyPlugins()); 
  Fluxy.autoRegister(); // Boots sensory core
  runApp(MyApp());
}
```

### 3. Usage (Unified API)
Access the module through the direct `Fx.log` helper.

```dart
void onAction() {
  Fx.log.sys("User performed an action", tag: 'USER_FLOW');
}

void onDataChange() {
  Fx.log.data("Database record updated", tag: 'STORAGE');
}

void onCrash(dynamic e, StackTrace s) {
  Fx.log.fatal("Critical exception!", error: e, stack: s);
}
```

---

## Semantic Levels

### 1. `sys()`
Use for lifecycle events or general system flow.
```dart
Fx.log.sys("Controller initialized");
```

### 2. `data()`
Use for state changes, network responses, or database ops.
```dart
Fx.log.data("API Fetch Successful [200 OK]");
```

### 3. `fatal()`
Use for try-catch blocks or unhandled exceptions. This also prints to the console in debug mode.
```dart
Fx.log.fatal("Authentication module failed to boot!");
```

---

## The Master Audit Implementation

In a professional application, logs are used for more than debugging; they are used for auditing, state tracking, and error reporting. Here is a complex "Submission Sequence" demonstrating best practices for sensory feedback.

```dart
class LogStore extends FluxController {
  
  // 1. Reactive log access for in-app developer tools
  late final sessionLogs = Fx.log.logs;
  
  void onAuditStart() {
    // 2. High-level system log
    Fx.log.sys("Audit session started.");
    
    // 3. Data-level log with tag
    Fx.log.data("Configuration loaded from encrypted storage.", tag: 'BOOT');
  }

  // 4. Using labels to identify logs in the stream
  void onProfileUpdate() {
    Fx.log.data("User profile patched with new avatar.", tag: 'USER');
    
    // You can iterate over Fx.log.logs (reactive) and show it in UI
    for (var entry in Fx.log.logs.value) {
      if (entry.contains('[FATAL]')) {
        Fx.toast.error("Critical issue detected in audit log!");
      }
    }
  }
}

// 5. In-App Performance Monitor (UI)
class LogConsole extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Fx(() => Fx.col(
      children: Fx.log.logs.value.map((log) => 
        Fx.text(log)
          .font.xs()
          .font.mono()
          .p(4)
          .border(0,0,1,0, FxTokens.colors.border)
      ).toList(),
    ).scrollable());
  }
}
```

By centralizing all sensory calls under the `Fx` namespace, you ensure that your haptics are consistent across the entire app and can be globally disabled or adjusted via the registry if needed.
